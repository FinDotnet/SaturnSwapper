@using Saturn.Backend.Data.Services
@using Saturn.Backend.Data.Variables
@using Saturn.Backend.Data.FortniteCentral
@using Saturn.Backend.Data.SaturnAPI.Models
@using Radon.Runtime
@using System.IO
@using System.Net
@using Newtonsoft.Json
@using Radon.CodeAnalysis.Disassembly
@using Radon.Runtime.Memory
@using Radon.Runtime.RuntimeSystem
@using Radon.Runtime.RuntimeSystem.RuntimeObjects
@using Saturn.Backend.Data
@using Saturn.Backend.Data.Plugins
@using Saturn.Backend.Data.Plugins.Marketplace
@using Saturn.Backend.Data.SaturnAPI

@inject IJSRuntime _jsRuntime;
@inject IFortniteCentralService _fortniteCentralService;
@inject LocalizationResourceService _localizationResourceService
@inject ISaturnAPIService _saturnAPIService

<PluginsSidebar/>
<div class="tab-page" id="plugin-page" style="display: none">
    @switch (Constants.CosmeticState)
    {
        case SaturnState.S_Plugin:
            if (Constants.OwnedPlugins.Count == 0)
            {
                <div class="tab-message">
                    <div class="text">
                        <h1>@NoPluginsKoomoji</h1>
                        <h3>You don't have any installed plugins</h3>
                        <h3>Download them from the marketplace!</h3>
                    </div>
                </div>
            }
            else
            {
                foreach (var plugin in Constants.OwnedPlugins)
                {
                    <div id="@(plugin.Name + "-section")" class="section hoverable" @onclick="@(async () => await Swap(plugin.AssemblyInfo))">
                        <img src=@(plugin.Icon) alt="Icon"/>
                        <div class="name">
                            <h1>@(plugin.Name + $" (v{plugin.Version})")</h1>
                            <h3>@("By: " + plugin.Author + " | " + plugin.Description)</h3>
                        </div>
                    </div>
                }
            }
            break;
        case SaturnState.S_Marketplace:
            foreach (var plugin in Marketplace)
            {
                <div id="@(plugin.Name + "-section")" class="section hoverable" @onclick="@(async () => await Download(plugin))">
                    <img src=@(plugin.Icon ?? "https://image.fnbr.co/outfit/5ab15c3e0499b850d8511de4/icon_192.png") alt="Icon"/>
                    <div class="name">
                        <h1>@(plugin.Name)</h1>
                        <h3>@("By: " + plugin.Author + " | " + plugin.Description)</h3>
                        @if (!string.IsNullOrWhiteSpace(plugin.Image))
                        {
                            <img src="@plugin.Image"/>
                        }
                    </div>
                </div>
            }
            break;
    }
</div>

@code {
    
    private string NoPluginsKoomoji = "(⇀‸↼‶)";
    private List<MarketplaceModel> Marketplace = new();

    protected override async Task OnInitializedAsync()
    {
        ChangeState();
        
        await RefreshPlugins();
        Marketplace = await _saturnAPIService.ReturnEndpointAsync<List<MarketplaceModel>>("/api/v1/Saturn/PluginMarketplace");
    }

    private async Task ChangeState()
    {
        while (true)
        {
            StateHasChanged();
            await Task.Delay(500);
        }
    }

    private async Task RefreshPlugins()
    {
        Constants.OwnedPlugins = new();
        foreach (var file in Directory.EnumerateFiles(Constants.PluginPath))
        {
            if (!file.EndsWith(".csp")) continue;

            var compiledPlugin = await File.ReadAllBytesAsync(file);
            var assembly = Disassembler.Disassemble(compiledPlugin);
            var assemblyInfo = new AssemblyInfo(assembly);

            string Name = "Unset Name";
            string Description = "Unset Description";
            string Version = "1.0.0";
            string Author = "Unset Author";
            string Icon = "https://image.fnbr.co/outfit/5ab15c3e0499b850d8511de4/icon_192.png";

            foreach (var sign in assemblyInfo.Metadata.Signs.Signs)
            {
                if (string.Equals(sign.Key, "name", StringComparison.CurrentCultureIgnoreCase))
                {
                    Name = sign.Value;
                }
                
                if (string.Equals(sign.Key, "description", StringComparison.CurrentCultureIgnoreCase))
                {
                    Description = sign.Value;
                }
                
                if (string.Equals(sign.Key, "version", StringComparison.CurrentCultureIgnoreCase))
                {
                    Version = sign.Value;
                }
                
                if (string.Equals(sign.Key, "author", StringComparison.CurrentCultureIgnoreCase))
                {
                    Author = sign.Value;
                }
                
                if (string.Equals(sign.Key, "icon", StringComparison.CurrentCultureIgnoreCase))
                {
                    Icon = sign.Value;
                }
            }
            
            Constants.OwnedPlugins.Add(new PluginModel()
            {
                Name = Name,
                Description = Description,
                AssemblyInfo = assemblyInfo,
                Author = Author,
                Icon = Icon,
                Version = Version
            });
        }
    }

    List<Guid> SwappedPlugins = new();
    private async Task Swap(AssemblyInfo assemblyInfo)
    {
        if (!SwappedPlugins.Contains(assemblyInfo.Guid))
        {
            await Convert(assemblyInfo);
            SwappedPlugins.Add(assemblyInfo.Guid);
            return;
        }

        await Revert(assemblyInfo);
        SwappedPlugins.Remove(assemblyInfo.Guid);
    }
    
    private async Task Download(MarketplaceModel plugin)
    {
        plugin.Description = $"Downloading {plugin.Name}...";
        if (!File.Exists(Path.Join(Constants.PluginPath, plugin.Name + ".saturn")))
        {
            WebClient wc = new WebClient();
            wc.DownloadFileAsync(new Uri(plugin.PluginURL), Path.Join(Constants.PluginPath, plugin.Name + ".saturn"));
        }
        plugin.Description = $"Successfully downloaded {plugin.Name}! You can now swap it in your library!";
        await Task.Delay(1000);
        await RefreshPlugins();
    }

    private async Task Convert(AssemblyInfo assemblyInfo)
    {
        MemoryUtils.HeapSize = 0x100000;
        MemoryUtils.StackSize = 0x100000;
        var runtime = new ManagedRuntime(assemblyInfo);
        Logger.Log($"Disassembled assembly {assemblyInfo.Guid}");
        var entryType = runtime.Types.First(type => type.Key.IsEntry).Value;
        var entryPoint = entryType.TypeInfo.Methods.First(method => method.IsEntry);
        entryType.InvokeStatic(assemblyInfo, entryPoint, ManagedRuntime.EmptyDictionary<ParameterInfo, RuntimeObject>());
        ManagedRuntime.StackManager.DeallocateStackFrame();
        ManagedRuntime.StackManager.FreeStack();
        ManagedRuntime.HeapManager.FreeHeap();
        Logger.Log($"Assembly {assemblyInfo.Guid} finished executing successfully!");
    }

    private async Task Revert(AssemblyInfo assemblyInfo)
    {
        var runtime = new ManagedRuntime(assemblyInfo);
        Logger.Log($"Disassembled assembly {assemblyInfo.Guid}");
        var entryType = runtime.Types.First(type => type.Key.IsEntry).Value;
        var entryPoint = entryType.TypeInfo.Methods.First(method => method.IsEntry);
        entryType.InvokeStatic(assemblyInfo, entryPoint, ManagedRuntime.EmptyDictionary<ParameterInfo, RuntimeObject>());
        ManagedRuntime.StackManager.DeallocateStackFrame();
        ManagedRuntime.StackManager.FreeStack();
        ManagedRuntime.HeapManager.FreeHeap();
    }
}